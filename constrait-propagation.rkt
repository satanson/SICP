#lang racket
(require r5rs)

(define (make-connector tag)
  
  (let ((value 0)
        (triggers '()))
    (define (getv) value)
    (define (setv! v)
      (display tag)(newline)
      (set! value v)
      (for-each (lambda(tr)(tr)) triggers))
    (define (add-trigger! tr)
      (set! triggers (cons tr triggers)))
   
    (define (get-triggers) triggers)
    (lambda (m)
      (cond ((eq? m 'setv!) setv!)
            ((eq? m 'getv) getv)
            ((eq? m 'add-trigger!) add-trigger!)
            ((eq? m 'get-triggers) get-triggers)
            (else (error "Not implemented method" m))))))

(define (setv! connector v)((connector 'setv!) v))
(define (getv connector)((connector 'getv)))
(define (add-trigger! connector tr) ((connector 'add-trigger!) tr))
(define (get-triggers connector) ((connector 'get-triggers)))
;(define cntr (make-connector))
;(add-trigger! cntr (lambda()(display "trigger1") (newline)))
;(add-trigger! cntr (lambda()(display "trigger2") (newline)))
;(setv! cntr 10)
;(getv cntr)

(define (adder-constrait a b c)
  (define (a-tr)
    (display "a-tr:\n")
    (let ((new-a (- (getv c) (getv b))))
      (or (eqv? (getv a) new-a)
          (setv! a new-a))))
  (define (b-tr)
    (display "b-tr:\n")
    (let ((new-b (- (getv c) (getv a))))
      (or (eqv? (getv b) new-b)
          (setv! b new-b))))
  (define (c-tr)
    (display "c-tr:\n")
    (let ((new-c (+ (getv a) (getv b))))
      (or (eqv? (getv c) new-c)
          (setv! c new-c))))
  (add-trigger! a b-tr)
  (add-trigger! a c-tr)
  (add-trigger! b a-tr)
  (add-trigger! b c-tr)
  (add-trigger! c a-tr)
  (add-trigger! c b-tr))

(define a (make-connector "a"))
(define b (make-connector "b"))
(define c (make-connector "c"))

(adder-constrait a b c)

(setv! a 0)
;(getv c)
(setv! b 10)
(getv c)
(setv! c 20)
(getv a)
(getv b)
(getv c)