#lang racket
(require r5rs)

(define (make-node next prev object)
  (define (set-next! n)(set! next n))
  (define (get-next) next)
  (define (set-prev! p)(set! prev p))
  (define (get-prev) prev)
  (define (set-object! o) (set! object o))
  (define (get-object) object)
  (lambda (m . xs)
    (cond ((eq? m 'set-next!) (apply set-next! xs))
          ((eq? m 'set-prev!) (apply set-prev! xs))
          ((eq? m 'set-object!) (apply set-object! xs))
          ((eq? m 'get-next) (apply get-next xs))
          ((eq? m 'get-prev) (apply get-prev xs))
          ((eq? m 'get-object) (apply get-object xs))
          (else "Not supported method" m))))


(define (perlish-array)
  (let ((_pointer (make-node '() '() '()))
        (_size 0))
    (_pointer 'set-next! _pointer)
    (_pointer 'set-prev! _pointer)
    
    (define (walk-n-steps pointer n)
      (if (eq? n 0)
          pointer
          (walk-n-steps (pointer 'get-next) (- n 1))))
    
    (define (pack-into-list pointer n)
      (define (iter p n ls)
        (if (eq? n 0)
            ls
            (iter (p 'get-next) (- n 1) (cons (p 'get-object) ls))))
      (reverse (iter pointer n '())))
    
    (define (push-list-onto pointer xs)
      (cond ((null? xs) pointer)
            (else
             (let ((new-node (make-node  (pointer 'get-next) pointer (car xs))))
               ((new-node 'get-prev) 'set-next! new-node)
               ((new-node 'get-next) 'set-prev! new-node)
               (push-list-onto new-node (cdr xs))))))
    
    (define (unsafe-splice! offset n  xs)
      (let* ((slice-begin-pointer (walk-n-steps (_pointer 'get-next) offset))
             (slice-end-pointer (walk-n-steps slice-begin-pointer n))
             (slice (pack-into-list slice-begin-pointer n)))
        
        ((slice-begin-pointer 'get-prev) 'set-next! slice-end-pointer)
        (slice-end-pointer 'set-prev! (slice-begin-pointer 'get-prev))
        (set! _size (+ (- _size n) (length xs)))
        (push-list-onto (slice-begin-pointer 'get-prev) xs)
        slice))
    
    (define (splice! offset n xs)
      (cond ((negative? offset)
             (cond ((positive? (+ offset _size))
                    (set! offset (+ offset _size)))
                   ((and (eq? offset -1) (eq? _size 0))
                    (set! offset 0))
                   (else (error "Offset is out of range" offset)))))
      (cond ((> (+ offset n) _size)
             (set! n (- _size offset)))
            ((eq? _size 0)
             (set! n 0)))
      (unsafe-splice! offset n xs))
    (define (->list)
      (define (iter p ls)
        (if (eq? p _pointer)
            ls
            (iter (p 'get-next)(cons (p 'get-object) ls))))
      (reverse (iter (_pointer 'get-next) '())))
    
    (lambda (m . args)
      (cond ((eq? m 'push!) (splice! _size 0 args) _size)
            ((eq? m 'pop!) (car (splice! (- _size 1) 1 '())))
            ((eq? m 'unshift!) (splice! 0 0 (reverse args)) _size)
            ((eq? m 'shift!) (car (splice! 0 1 '())))
            ((eq? m 'length) _size)
            ((eq? m 'empty?) (eq? _size 0))
            ((eq? m 'splice!) (apply splice! args))
            ((eq? m '->list) (->list))
            ((eq? m '->string) (display (->list)) (newline))
            (else (error "Not supported method" m))))))

(define array (perlish-array)) 
(array 'push! 1 2 3 4 5)
(array 'unshift! 1 2 3 4 5)
(array 'length)
(array '->list)
(array '->string)
(array 'length)
(define slice (array 'splice! 1 5 '(2 3 4 5)))
(array '->string)
