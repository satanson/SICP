#lang racket
(require r5rs)

(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (push! e)
      (let ((new-pair (cons e '())))
        (cond ((empty?)
               (set! front-ptr new-pair)
               (set! rear-ptr new-pair)
               front-ptr)
              (else
               (set-cdr! rear-ptr new-pair)
               (set! rear-ptr new-pair)
               front-ptr))))
    
    (define (pop!)
      (if (empty?)
          (error "Can't pop anything from empty queue" front-ptr)
          (let ((head (car front-ptr))
                (tail (cdr front-ptr)))
            (cond ((null? tail)
                   (set! front-ptr '())
                   (set! rear-ptr '())
                   head)
                  (else
                   (set! front-ptr tail)
                   head)))))
          
    (define (empty?)(null? front-ptr))
    (define (->string) (display front-ptr) (newline))
    (lambda(m)
      (cond ((eq? m 'push!) push!)
            ((eq? m 'pop!) pop!)
            ((eq? m 'empty?) empty?)
            ((eq? m '->string) ->string)
            (else (error "Not supported method" m))))))

(define q (make-queue))
((q 'empty?))
((q 'push!) 1)
((q 'empty?))
((q '->string))
((q 'push!) 1)
((q 'empty?))
((q '->string))

((q 'push!) 1)
((q 'empty?))
((q '->string))
((q 'pop!))
((q 'pop!))

((q '->string))

(define (make-node next prev object)
  (define (set-next! n)(set! next n))
  (define (get-next) next)
  (define (set-prev! p)(set! prev p))
  (define (get-prev) prev)
  (define (set-object! o) (set! object o))
  (define (get-object) object)
  (lambda (m . xs)
    (cond ((eq? m 'set-next!) (apply set-next! xs))
          ((eq? m 'set-prev!) (apply set-prev! xs))
          ((eq? m 'set-object!) (apply set-object! xs))
          ((eq? m 'get-next) (apply get-next xs))
          ((eq? m 'get-prev) (apply get-prev xs))
          ((eq? m 'get-object) (apply get-object xs))
          (else "Not supported method" m))))
(define (perlish-array)
  (let ((_pointer (make-node '() '() '()))
        (_length 0))
    (_pointer 'set-next! _pointer)
    (_pointer 'set-prev! _pointer)
    
    (define (walk-n-steps pointer n)
      (if (eq? n 0)
          pointer
          (walk-n-steps (pointer 'get-next) (- n 1))))
    
    (define (pack-into-list pointer n)
      (if (eq? n 0)
          '()
          (cons (pointer 'get-object) (pack-into-list (pointer 'get-next) (- n 1)))))
    
    (define (push-list-onto pointer xs)
      (cond ((null? xs) pointer)
            (else
             (let ((new-node (make-node  (pointer 'get-prev) pointer (car xs))))
               ((new-node 'get-prev) 'set-next! new-node)
               ((new-node 'get-next) 'set-prev! new-node)
               (push-list-onto new-node (cdr xs))))))
    
    (define (unsafe-splice! offset n . xs)
      (let* ((slice-begin-pointer (walk-n-steps _pointer offset))
             (slice-end-pointer (walk-n-steps slice-begin-pointer n))
             (slice (pack-into-list slice-begin-pointer n)))
        
        ((slice-begin-pointer 'get-prev) 'set-next slice-end-pointer)
        ((slice-end-pointer 'get-next) 'set-prev slice-begin-pointer)
        (set! _length (+ (- _length n) (length xs)))
        (push-list-onto (slice-begin-pointer 'get-prev) xs)
        slice))
    
    (define (splice! offset n xs)
      (cond ((negative? offset)
             (cond ((negative? (+ offset _length))
                    (set! offset (+ offset _length)))
                   (else (error "Offset is out of range" offset)))))
      (cond ((> (+ offset n) _length)
             (set! n (- _length offset))))
      (unsafe-splice! offset n xs))
        
    (lambda (m . args)
      (cond ((eq? m 'push!) (splice! (- _length 1) 0 args))
            ((eq? m 'pop!) (splice! (- _length 1) 1))
            ((eq? m 'unshift!) (splice! 0 0 args))
            ((eq? m 'shift!) (splice! 0 1))
            ((eq? m 'length) _length)
            ((eq? m 'empty) (eq? _length 0))
            ((eq? m 'splice!) (apply splice! args))
            ((eq? m '->list) (splice! 0 _length))
            ((eq? m '->string) (display (splice! 0 _length)) (newline))
            (else (error "Not supported method" m))))))

(define array (perlish-array)) 
(array 'push! 1)
(array 'push! 2)
(array '->string)
        